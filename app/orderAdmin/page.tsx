"use client";

import { useState, useEffect, useRef, useCallback } from "react";
import {
  Box,
  Button,
  Grid,
  Heading,
  Text,
  VStack,
  useColorMode,
  Input,
  Textarea,
  Select,
  FormControl,
  FormLabel,
  useToast,
  Image,
  HStack,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  ModalCloseButton,
  useDisclosure,
  Checkbox,
  Avatar,
  Flex,
  Center,
  Tab,
  Tabs,
  TabList,
  InputGroup,
  NumberInput,
  NumberInputField,
  InputRightAddon,
  NumberInputStepper,
  NumberIncrementStepper,
  NumberDecrementStepper,
} from "@chakra-ui/react";
import { supabase } from "@/utils/supabase/client";
import { VscAccount } from "react-icons/vsc";
import imageCompression from "browser-image-compression";
import { useUserContext } from "@/contexts/useUserContext";
import Content from "@/components/content";
import { FaAnglesDown } from "react-icons/fa6";
import { MyBarChart } from "../order/parts/nutrientGraph";
import {
  CATEGORY_CONFIG,
  NUTRIENTS_CONFIG_,
  searchCategoryBg,
  searchCategoryColor,
  MenuItem,
} from "../utils/categoryConfig";

interface Order {
  id: number;
  total: number;
  created_at: string;
  status: "pending" | "completed";
  user_id: string;
  order_items: {
    id: number;
    menu_item_id: number;
    quantity: number;
    price: number;
    status: "pending" | "completed";
    menu_item: {
      id: number;
      name: string;
      image_url: string;
    };
  }[];
}

export default function AdminPage() {
  const { colorMode } = useColorMode();
  const toast = useToast();
  const fileInputRef = useRef<HTMLInputElement>(null);
  const fileInputSubRef = useRef<HTMLInputElement>(null);
  const { isOpen, onOpen, onClose } = useDisclosure();
  const {
    isOpen: isIngredientsModalOpen,
    onOpen: onIngredientsModalOpen,
    onClose: onIngredientsModalClose,
  } = useDisclosure();
  const {
    isOpen: isRecipeModalOpen,
    onOpen: onRecipeModalOpen,
    onClose: onRecipeModalClose,
  } = useDisclosure();
  const {
    isOpen: isDeleteConfirmModalOpen,
    onOpen: onDeleteConfirmModalOpen,
    onClose: onDeleteConfirmModalClose,
  } = useDisclosure();
  const {
    isOpen: isCompleteConfirmModalOpen,
    onOpen: onCompleteConfirmModalOpen,
    onClose: onCompleteConfirmModalClose,
  } = useDisclosure();
  const {
    isOpen: isLocationModalOpen,
    onOpen: onLocationModalOpen,
    onClose: onLocationModalClose,
  } = useDisclosure();
  const {
    isOpen: isApplyConfirmModalOpen,
    onOpen: onApplyConfirmModalOpen,
    onClose: onApplyConfirmModalClose,
  } = useDisclosure();
  const [menuItems, setMenuItems] = useState<MenuItem[]>([]);
  const [newItem, setNewItem] = useState<Partial<MenuItem>>({
    name: "",
    price: undefined,
    category: "",
    imageUrl: "",
    imageUrlSub: "",
    ingredients: [],
    is_visible: true,
    recommendation_level: 0,
    estimated_time: 0,
    recipe: "",
    isSoldOut: false,
    nutrients: [],
  });
  const [editingItem, setEditingItem] = useState<MenuItem | null>(null);
  const [previewImage, setPreviewImage] = useState<string>("");
  const [previewImageSub, setPreviewImageSub] = useState<string>("");
  const [ingredientInputs, setIngredientInputs] = useState<string[]>([""]);
  const [ingredientLocations, setIngredientLocations] = useState<{
    [key: string]: string;
  }>({});
  const [orders, setOrders] = useState<Order[]>([]);
  const [formValues, setFormValues] = useState<{ [key: string]: number }>({});

  const handleChange = (label: string, value: number) => {
    setNutrientValues((prev) => ({
      ...prev,
      [label]: value,
    }));
  };
  const {
    currentUserId,
    currentUserPictureUrl,
    currentUserEmail,
    currentUserCreatedAt,
    getUserById,
    isLoading,
  } = useUserContext();

  const userData = currentUserId ? getUserById(currentUserId) : null;
  const audioRef = useRef<HTMLAudioElement | null>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const [selectedRecipe, setSelectedRecipe] = useState<string>("");
  const [itemToDelete, setItemToDelete] = useState<{ id: number } | null>(null);
  const [itemToComplete, setItemToComplete] = useState<{
    id: number;
    menuItemId: number;
  } | null>(null);
  const [selectedIngredient, setSelectedIngredient] = useState<string>("");
  const [checkedItems, setCheckedItems] = useState<{ [key: string]: boolean }>(
    {}
  );
  const [imageCache, setImageCache] = useState<{ [key: string]: string }>({});
  const [preloadedImages, setPreloadedImages] = useState<{
    [key: string]: HTMLImageElement;
  }>({});
  const [showVisibleOnly, setShowVisibleOnly] = useState(false);
  const [nutrientValues, setNutrientValues] = useState<Record<string, number>>(
    {}
  );

  const handleCopyToClipboardNutrients = () => {
    const nutrients = Object.entries(NUTRIENTS_CONFIG_).map(
      ([key, value]) => `${key} (${value.unit})`
    );
    const name = newItem.name;
    const recipe = newItem.recipe;
    const textToCopy =
      name +
      "\n" +
      recipe +
      "\n\n" +
      "„Åì„ÅÆ„É¨„Ç∑„Éî„ÅÆ1‰∫∫Ââç„ÅÆÂ†¥Âêà„ÅÆ" +
      nutrients.join(", ") +
      "„ÇíÊïô„Åà„Å¶„ÄÇ„Çπ„Éº„Éó„ÅåÊúâ„Çã„ÅØÈ£≤„ÅøÂπ≤„Åï„Å™„ÅÑ„ÄÇ" +
      "\n\n";
    navigator.clipboard
      .writeText(textToCopy)
      .then(() => {
        toast({
          title: "„Ç≥„Éî„ÉºÊàêÂäü",
          description: "Ê†ÑÈ§äÁ¥†„Åå„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åï„Çå„Åæ„Åó„Åü„ÄÇ",
          status: "success",
          duration: 3000,
          isClosable: true,
        });
      })
      .catch((err) => {
        console.error("„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å∏„ÅÆ„Ç≥„Éî„Éº„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:", err);
        toast({
          title: "„Ç≥„Éî„ÉºÂ§±Êïó",
          description: "„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å∏„ÅÆ„Ç≥„Éî„Éº„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ",
          status: "error",
          duration: 3000,
          isClosable: true,
        });
      });
  };

  const handleCopyToClipboardRecipe = () => {
    const ingredient = Object.entries(ingredientInputs).map(
      ([key, value]) => `${value}`
    );

    const textToCopy =
      "ÊùêÊñô„Å´„ÄÅ" +
      ingredient.join(", ") +
      "„Çí‰Ωø„Å£„Åü" +
      newItem.name +
      "„ÅÆ„É¨„Ç∑„Éî„ÇíÊïô„Åà„Å¶" +
      "\n\n" +
      "„Åù„ÅÆ„Åæ„Åæ„ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢„Å´Ë≤º„Çä‰ªò„Åë„Åü„ÅÑ„Åã„Çâ„Éï„Ç©„Éº„Éû„ÉÉ„Éà„ÅØÂøÖ„ÅöÊ¨°„ÅÆ„Çà„ÅÜ„Å´„Åó„Å¶„ÄÇ‰ΩôË®à„Å™„É°„ÉÉ„Çª„Éº„Ç∏„ÅØÂê´„ÇÅ„Å™„ÅÑ„Åß„ÄÇ\n" +
      "‰ª•‰∏ã„ÅØ„Ç¨„Éº„É™„ÉÉ„ÇØ„Éù„ÉÜ„Éà„Çµ„É©„ÉÄ„ÅÆ„É¨„Ç∑„Éî„ÅÆ‰æã„Å≠\n\n" +
      "ü•¶ ÊùêÊñô(2-3‰∫∫Ââç)\n" +
      "„Åò„ÇÉ„Åå„ÅÑ„ÇÇ:2ÂÄã\nÁéâ„Å≠„Åé:1/4ÂÄã\n„Éô„Éº„Ç≥„É≥:60g\n„Å´„Çì„Å´„Åè:2Áâá\n„Éë„Çª„É™:ÈÅ©Èáè\n\n" +
      "üç≥ ‰Ωú„ÇäÊñπ\n" +
      "1. A: „Å´„Çì„Å´„Åè„Çí„Çπ„É©„Ç§„Çπ„Åó„ÄÅÁéâ„Å≠„Åé„Çí„Çπ„É©„Ç§„Çπ„ÄÅ„Åò„ÇÉ„Åå„ÅÑ„ÇÇ„ÇíË¶™Êåá„Åè„Çâ„ÅÑ„Å´„Ç´„ÉÉ„Éà\n\n" +
      "2. A„ÇíÈõªÂ≠ê„É¨„É≥„Ç∏„Åß6ÂàÜ600w„ÅßÂä†ÁÜ±\n\n" +
      "3. B: „Éô„Éº„Ç≥„É≥„Çí„Åø„Åò„ÇìÂàá„Çä„Å´„Åó„ÄÅ„Ç™„É™„Éº„Éñ„Ç™„Ç§„É´„ÅßÁÑº„Åè\n\n" +
      "4. A„Å´B„ÇíÂä†„Åà„ÄÅÂ¥©„Åó„Å™„Åå„ÇâÊ∑∑„Åú„ÄÅÊ∏©Â∫¶„Çí‰∏ã„Åí„Çã\n\n" +
      "5. ‰∫∫ËÇå„Å´„Å™„Çã„Åæ„ÅßÊîæÁΩÆ\n\n" +
      "6. „Éû„É®„Éç„Éº„Ç∫„ÇíÂ§ß„Åï„Åò3.5ÂÖ•„Çå„Å¶Ê∑∑„Åú„Çã\n\n" +
      "7. C: ÈªíËÉ°Ê§íÔºàÂ§ö„ÇÅÔºâ„ÄÅÂ°©ÔºàÂ∞è„Åï„Åò1/3Ôºâ„ÄÅÁ†ÇÁ≥ñÔºàÂ∞è„Åï„Åò1Ôºâ„ÄÅÂë≥„ÅÆÁ¥†Ôºà6ÊåØ„ÇäÔºâ„ÇíÂä†„Åà„Å¶Ê∑∑„Åú„Çã\n\n" +
      "üí° „Éù„Ç§„É≥„Éà\n" +
      "„Ç¨„Éº„É™„ÉÉ„ÇØ„ÅÆÈ¶ô„Çä„ÅåÂäπ„ÅÑ„Åü„ÄÅ„Ç≥„ÇØ„ÅÆ„ÅÇ„Çã„Éù„ÉÜ„Éà„Çµ„É©„ÉÄ„ÄÇ„Éô„Éº„Ç≥„É≥„ÅÆÊó®Âë≥„Åå„Ç¢„ÇØ„Çª„É≥„Éà„Å´ÔºÅ";

    navigator.clipboard
      .writeText(textToCopy)
      .then(() => {
        toast({
          title: "„Ç≥„Éî„ÉºÊàêÂäü",
          description: "„É¨„Ç∑„ÉîÊèêÊ°à„Åå„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åï„Çå„Åæ„Åó„Åü„ÄÇ",
          status: "success",
          duration: 3000,
          isClosable: true,
        });
      })
      .catch((err) => {
        console.error("„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å∏„ÅÆ„Ç≥„Éî„Éº„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:", err);
        toast({
          title: "„Ç≥„Éî„ÉºÂ§±Êïó",
          description: "„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å∏„ÅÆ„Ç≥„Éî„Éº„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ",
          status: "error",
          duration: 3000,
          isClosable: true,
        });
      });
  };

  // ÁîªÂÉè„ÅÆ„Éó„É™„É≠„Éº„ÉâÈñ¢Êï∞
  const preloadImage = useCallback(
    (url: string) => {
      if (!preloadedImages[url]) {
        const img = document.createElement("img");
        img.src = url;
        img.crossOrigin = "anonymous";
        setPreloadedImages((prev) => ({ ...prev, [url]: img }));
      }
    },
    [preloadedImages]
  );

  const categories = [
    "„Åô„Åπ„Å¶",
    ...Object.entries(CATEGORY_CONFIG)
      .sort((a, b) => a[1].order - b[1].order)
      .map(([name]) => name),
  ];
  const locations = [
    "ÈÖíÈ°û",
    "„Éë„É≥È°û",
    "‰π≥Ë£ΩÂìÅ",
    "Á≤æËÇâ",
    "Ë™øÂë≥Êñô",
    "ÈÆÆÈ≠ö",
    "ÈùíÊûú",
    "„ÅäÁ±≥",
    "KALDI",
    "„É™„Ç´„Ç™„Éº",
    "„Åù„ÅÆ‰ªñ",
  ];

  const locationTextColors = {
    ÈÖíÈ°û: "purple.600",
    „Éë„É≥È°û: "orange.600",
    ‰π≥Ë£ΩÂìÅ: "blue.600",
    Á≤æËÇâ: "red.600",
    Ë™øÂë≥Êñô: "orange.600",
    ÈÆÆÈ≠ö: "cyan.600",
    ÈùíÊûú: "green.600",
    „ÅäÁ±≥: "yellow.600",
    KALDI: "pink.600",
    „É™„Ç´„Ç™„Éº: "pink.400",
    „Åù„ÅÆ‰ªñ: "gray.600",
  };

  const [selectedCategory, setSelectedCategory] = useState<string>("„Åô„Åπ„Å¶");
  const handleCategoryChange = (category: string) => {
    setSelectedCategory(category);
  };
  const filteredItems =
    selectedCategory === "„Åô„Åπ„Å¶"
      ? menuItems
          .map((item) => ({
            ...item,
            imageUrl: imageCache[item.imageUrl] || item.imageUrl,
            imageUrlSub: imageCache[item.imageUrlSub] || item.imageUrlSub,
            quantity: 1,
          }))
          .sort((a, b) => {
            const orderA = categories.indexOf(a.category);
            const orderB = categories.indexOf(b.category);
            return orderA - orderB;
          })
      : menuItems
          .filter((item) => item.category === selectedCategory)
          .map((item) => ({
            ...item,
            imageUrl: imageCache[item.imageUrl] || item.imageUrl,
            imageUrlSub: imageCache[item.imageUrlSub] || item.imageUrlSub,
            quantity: 1, // quantity „Çí 1 „Å´Ë®≠ÂÆö
          }))
          .sort((a, b) => {
            const orderA = categories.indexOf(a.category);
            const orderB = categories.indexOf(b.category);
            return orderA - orderB;
          });

  const adjustTextareaHeight = useCallback((element: HTMLTextAreaElement) => {
    element.style.height = "auto";
    element.style.height = `${element.scrollHeight}px`;
  }, []);

  useEffect(() => {
    if (isOpen && textareaRef.current) {
      adjustTextareaHeight(textareaRef.current);
    }
  }, [isOpen, newItem.recipe, adjustTextareaHeight]);

  useEffect(() => {
    fetchMenuItems();
    fetchOrders();
    const cleanup = setupRealtimeSubscription();
    return () => cleanup();
  }, []);

  useEffect(() => {
    const nutrientMap: Record<string, number> = {};
    menuItems
      .filter((item) => item.is_visible)
      .forEach((item) => {
        if (Array.isArray(item.nutrients)) {
          item.nutrients.forEach((n) => {
            const [name, value] = n.split(":");
            const num = parseFloat(value);
            if (!isNaN(num)) {
              nutrientMap[name] = (nutrientMap[name] || 0) + num;
            }
          });
        }
      });
    setNutrientValues(nutrientMap);
  }, [menuItems]);

  const fetchMenuItems = async () => {
    const { data, error } = await supabase
      .from("order_menu_items")
      .select("*, image_url_sub")
      .order("id", { ascending: true });

    if (error) {
      toast({
        title: "„Ç®„É©„Éº",
        description: "„É°„Éã„É•„Éº„Ç¢„Ç§„ÉÜ„É†„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    // ÁîªÂÉèURL„Çí„Ç≠„É£„ÉÉ„Ç∑„É•„Åó„ÄÅ„Éó„É™„É≠„Éº„Éâ
    const itemsWithCorrectImageUrl =
      data?.map((item) => {
        // ÊùêÊñô„Éá„Éº„Çø„ÅÆÂá¶ÁêÜ
        let parsedIngredients = [];
        try {
          parsedIngredients = item.ingredients.map((ing: string) => {
            if (typeof ing === "string") {
              return JSON.parse(ing);
            }
            return ing;
          });
        } catch (e) {
          console.error("ÊùêÊñô„Éá„Éº„Çø„ÅÆ„Éë„Éº„Çπ„Å´Â§±Êïó:", e);
          parsedIngredients = [];
        }

        const imageUrl = item.image_url;
        const imageUrlSub = item.image_url_sub;
        if (imageUrl && !imageCache[imageUrl]) {
          setImageCache((prev) => ({ ...prev, [imageUrl]: imageUrl }));
          preloadImage(imageUrl);
        }
        if (imageUrlSub && !imageCache[imageUrlSub]) {
          setImageCache((prev) => ({ ...prev, [imageUrlSub]: imageUrlSub }));
          preloadImage(imageUrlSub);
        }

        return {
          ...item,
          imageUrl: preloadedImages[imageUrl]?.src || imageUrl,
          imageUrlSub: preloadedImages[imageUrlSub]?.src || imageUrlSub,
          ingredients: parsedIngredients,
        };
      }) || [];

    setMenuItems(itemsWithCorrectImageUrl);
  };

  const fetchOrders = async () => {
    const { data, error } = await supabase
      .from("orders")
      .select(
        `
        *,
        order_items (
          id,
          menu_item_id,
          quantity,
          price,
          status,
          menu_item:menu_item_id (
            id,
            name,
            image_url
          )
        )
      `
      )
      .order("created_at", { ascending: false });

    if (error) {
      toast({
        title: "„Ç®„É©„Éº",
        description: "Ê≥®Êñá„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
      return;
    }
    setOrders(data || []);
  };

  const setupRealtimeSubscription = () => {
    const subscription = supabase
      .channel("orders")
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "orders",
        },
        async (payload) => {
          if (payload.eventType === "INSERT") {
            // Êñ∞„Åó„ÅÑÊ≥®Êñá„ÅåËøΩÂä†„Åï„Çå„ÅüÊôÇ„Å´ÈÄöÁü•Èü≥„ÇíÂÜçÁîü
            if (audioRef.current) {
              audioRef.current.play().catch((error) => {
                console.error("Error playing sound:", error);
              });
            }
            // „Éà„Éº„Çπ„ÉàÈÄöÁü•„ÇíË°®Á§∫
            toast({
              title: "Êñ∞„Åó„ÅÑÊ≥®Êñá",
              description: "Êñ∞„Åó„ÅÑÊ≥®Êñá„ÅåÂÖ•„Çä„Åæ„Åó„Åü",
              status: "info",
              duration: 5000,
              isClosable: true,
            });
          }
          await fetchOrders();
        }
      )
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "order_items",
        },
        async (payload) => {
          await fetchOrders();
        }
      )
      .subscribe();

    return () => {
      subscription.unsubscribe();
    };
  };

  const handleOrderStatusChange = async (
    itemId: number,
    newStatus: "pending" | "completed"
  ) => {
    try {
      // orders„ÉÜ„Éº„Éñ„É´„ÅÆÊõ¥Êñ∞
      const { error: orderError } = await supabase
        .from("orders")
        .update({ status: newStatus })
        .eq("id", itemId);

      if (orderError) throw orderError;

      // order_items„ÉÜ„Éº„Éñ„É´„ÅÆÊõ¥Êñ∞
      const { error: itemsError } = await supabase
        .from("order_items")
        .update({
          status: newStatus,
          completed_at: new Date(), // ‚Üê ÁèæÂú®„ÅÆÊó•ÊôÇ„Çí„Çª„ÉÉ„Éà
        })

        .eq("id", itemId);

      if (itemsError) throw itemsError;

      toast({
        title: "ÊàêÂäü",
        description: "Ê≥®Êñá„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü",
        status: "success",
        duration: 3000,
        isClosable: true,
      });

      await fetchOrders();
    } catch (error) {
      console.error("Error updating order status:", error);
      toast({
        title: "„Ç®„É©„Éº",
        description: "Ê≥®Êñá„Çπ„ÉÜ„Éº„Çø„Çπ„ÅÆÊõ¥Êñ∞„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
    }
  };

  const handleImageUpload = async (
    e: React.ChangeEvent<HTMLInputElement>,
    isSubImage: boolean
  ) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // „Éó„É¨„Éì„É•„ÉºË°®Á§∫
    const reader = new FileReader();
    reader.onloadend = () => {
      if (isSubImage) {
        setPreviewImageSub(reader.result as string);
      } else {
        setPreviewImage(reader.result as string);
      }
    };
    reader.readAsDataURL(file);

    try {
      // ÁîªÂÉè„ÇíWebPÂΩ¢Âºè„Å´Â§âÊèõ
      const options = {
        maxSizeMB: 0.7,
        maxWidthOrHeight: 1200,
        useWebWorker: true,
        fileType: "image/webp",
        initialQuality: 0.7,
        alwaysKeepResolution: true,
      };

      const compressedFile = await imageCompression(file, options);

      // „Éï„Ç°„Ç§„É´Âêç„ÇíÁîüÊàêÔºà„Çø„Ç§„É†„Çπ„Çø„É≥„Éó + .webpÔºâ
      const fileName = `${Date.now()}.webp`;
      const filePath = `${fileName}`;

      // Supabase Storage„Å´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ
      const { error: uploadError } = await supabase.storage
        .from("menu-image")
        .upload(filePath, compressedFile);

      if (uploadError) {
        toast({
          title: "„Ç®„É©„Éº",
          description: "ÁîªÂÉè„ÅÆ„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
          status: "error",
          duration: 3000,
          isClosable: true,
        });
        return;
      }

      // „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„ÅüÁîªÂÉè„ÅÆURL„ÇíÂèñÂæó
      const {
        data: { publicUrl },
      } = supabase.storage.from("menu-image").getPublicUrl(filePath);

      if (isSubImage) {
        setNewItem({ ...newItem, imageUrlSub: publicUrl });
      } else {
        setNewItem({ ...newItem, imageUrl: publicUrl });
      }
    } catch (error) {
      console.error("Error compressing image:", error);
      toast({
        title: "„Ç®„É©„Éº",
        description: "ÁîªÂÉè„ÅÆÂá¶ÁêÜ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
    }
  };

  const handleIngredientChange = (index: number, value: string) => {
    const newInputs = [...ingredientInputs];
    newInputs[index] = value;
    setIngredientInputs(newInputs);

    // ÊúÄÂæå„ÅÆÂÖ•ÂäõÊ¨Ñ„ÅåÂüã„Åæ„Å£„Åü„ÇâÊñ∞„Åó„ÅÑÂÖ•ÂäõÊ¨Ñ„ÇíËøΩÂä†
    if (index === newInputs.length - 1 && value.trim() !== "") {
      setIngredientInputs([...newInputs, ""]);
    }
  };

  const handleLocationSelect = (location: string) => {
    setIngredientLocations((prev) => ({
      ...prev,
      [selectedIngredient]: location,
    }));
    onLocationModalClose();
  };

  const handlePriceChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    // Á©∫ÊñáÂ≠óÂàó„Åæ„Åü„ÅØÊï∞ÂÄ§„ÅÆ„Åø„ÇíË®±ÂèØ
    if (value === "" || /^\d*$/.test(value)) {
      setNewItem({
        ...newItem,
        price: value === "" ? undefined : Number(value),
      });
    }
  };

  const handleRecipeChange = useCallback(
    (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      setNewItem((prev) => ({ ...prev, recipe: e.target.value }));
      adjustTextareaHeight(e.target);
    },
    [adjustTextareaHeight]
  );

  const resetNewItemForm = () => {
    // „Éï„Ç©„Éº„É†„Çí„É™„Çª„ÉÉ„Éà
    setNewItem({
      name: "",
      price: undefined,
      category: "",
      imageUrl: "",
      imageUrlSub: "",
      ingredients: [],
      is_visible: true,
      recommendation_level: 0,
      estimated_time: 0,
      recipe: "",
      isSoldOut: false,
      nutrients: [],
    });
    setPreviewImage("");
    setPreviewImageSub("");
    setNutrientValues({});
    setEditingItem(null);
    setIngredientInputs([""]);
    onClose();
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!userData?.user_metadata?.name) {
      toast({
        title: "„Ç®„É©„Éº",
        description: "Ë™çË®º„Åï„Çå„Å¶„ÅÑ„Çã„É¶„Éº„Ç∂„Éº„ÅÆ„Åø‰ΩøÁî®„Åß„Åç„Åæ„Åô",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
      return;
    }
    // ‰æ°Ê†º„ÅåÊú™ÂÖ•Âäõ„ÅÆÂ†¥Âêà„ÅØ„Ç®„É©„Éº
    if (newItem.price === undefined) {
      toast({
        title: "„Ç®„É©„Éº",
        description: "‰æ°Ê†º„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    // Á©∫„ÅÆÊùêÊñô„ÇíÈô§Â§ñ„Åó„Å¶‰øùÂ≠ò
    const validIngredients = ingredientInputs
      .filter((ingredient) => ingredient.trim() !== "")
      .map((ingredient) => ({
        name: ingredient.trim(),
        location: ingredientLocations[ingredient] || "„Åù„ÅÆ‰ªñ",
      }));

    const formattedNutrients = Object.entries(nutrientValues)
      .filter(([_, value]) => value != null && !isNaN(value))

      .map(([key, value]) => `${key}:${value}`);

    try {
      if (editingItem) {
        // Êõ¥Êñ∞Ââç„ÅÆÁîªÂÉèURL„Çí‰øùÂ≠ò
        const oldImageUrl = editingItem.imageUrl;
        const oldImageUrlSub = editingItem.imageUrlSub;

        // Êõ¥Êñ∞„Åô„Çã„Éá„Éº„Çø„ÇíÊ∫ñÂÇô
        const updateData: any = {
          name: newItem.name,
          price: newItem.price,
          category: newItem.category,
          ingredients: validIngredients,
          is_visible: newItem.is_visible,
          recipe: newItem.recipe,
          recommendation_level: newItem.recommendation_level,
          estimated_time: newItem.estimated_time,
          created_at: new Date(),
          user_id: currentUserId,
          nutrients: formattedNutrients,
        };

        // ÁîªÂÉè„ÅåÂ§âÊõ¥„Åï„Çå„ÅüÂ†¥Âêà„ÅÆ„ÅøÊõ¥Êñ∞
        if (newItem.imageUrl && newItem.imageUrl !== oldImageUrl) {
          updateData.image_url = newItem.imageUrl;
        }
        if (newItem.imageUrlSub && newItem.imageUrlSub !== oldImageUrlSub) {
          updateData.image_url_sub = newItem.imageUrlSub;
        }

        const { error } = await supabase
          .from("order_menu_items")
          .update(updateData)
          .eq("id", editingItem.id);

        if (error) {
          toast({
            title: "„Ç®„É©„Éº",
            description: "„É°„Éã„É•„Éº„Ç¢„Ç§„ÉÜ„É†„ÅÆÊõ¥Êñ∞„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
            status: "error",
            duration: 3000,
            isClosable: true,
          });
          return;
        }

        // ÁîªÂÉè„ÅåÂ§âÊõ¥„Åï„Çå„ÅüÂ†¥Âêà„ÄÅÂè§„ÅÑÁîªÂÉè„ÇíÂâäÈô§
        if (
          oldImageUrl &&
          newItem.imageUrl &&
          oldImageUrl !== newItem.imageUrl
        ) {
          const oldImagePath = oldImageUrl.split("/").pop();
          if (oldImagePath) {
            const { error: deleteError } = await supabase.storage
              .from("menu-image")
              .remove([oldImagePath.split("?")[0]]);

            if (deleteError) {
              console.error("Error deleting old image:", deleteError);
            }
          }
        }

        if (
          oldImageUrlSub &&
          newItem.imageUrlSub &&
          oldImageUrlSub !== newItem.imageUrlSub
        ) {
          const oldImageSubPath = oldImageUrlSub.split("/").pop();
          if (oldImageSubPath) {
            const { error: deleteError } = await supabase.storage
              .from("menu-image")
              .remove([oldImageSubPath.split("?")[0]]);

            if (deleteError) {
              console.error("Error deleting old sub image:", deleteError);
            }
          }
        }
      } else {
        const { error } = await supabase.from("order_menu_items").insert([
          {
            name: newItem.name,
            price: newItem.price,
            category: newItem.category,
            image_url: newItem.imageUrl,
            image_url_sub: newItem.imageUrlSub,
            ingredients: validIngredients,
            is_visible: newItem.is_visible,
            recipe: newItem.recipe,
            recommendation_level: newItem.recommendation_level,
            estimated_time: newItem.estimated_time,
            nutrients: formattedNutrients,
          },
        ]);

        if (error) {
          toast({
            title: "„Ç®„É©„Éº",
            description: "„É°„Éã„É•„Éº„Ç¢„Ç§„ÉÜ„É†„ÅÆËøΩÂä†„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
            status: "error",
            duration: 3000,
            isClosable: true,
          });
          return;
        }
      }

      toast({
        title: "ÊàêÂäü",
        description: editingItem
          ? "„É°„Éã„É•„Éº„Ç¢„Ç§„ÉÜ„É†„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü"
          : "„É°„Éã„É•„Éº„Ç¢„Ç§„ÉÜ„É†„ÇíËøΩÂä†„Åó„Åæ„Åó„Åü",
        status: "success",
        duration: 3000,
        isClosable: true,
      });

      resetNewItemForm();

      // „É°„Éã„É•„Éº„Ç¢„Ç§„ÉÜ„É†„ÇíÂÜçÂèñÂæó
      fetchMenuItems();
    } catch (error) {
      console.error("Error in submit process:", error);
      toast({
        title: "„Ç®„É©„Éº",
        description: "Âá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
    }
  };

  const handleEdit = async (item: MenuItem) => {
    if (userData?.user_company !== "ÈñãÁô∫") {
      toast({
        title: "„Ç®„É©„Éº",
        description: "„Åì„ÅÆÊ©üËÉΩ„ÅØ„Çµ„Éñ„Çπ„ÇØÂ•ëÁ¥ÑËÄÖ„ÅÆ„Åø‰ΩøÁî®„Åß„Åç„Åæ„Åô",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
      return;
    }
    setEditingItem(item);
    const formattedNutrients = Object.entries(nutrientValues)
      .filter(([_, value]) => value != null && !isNaN(value))

      .map(([key, value]) => `${key}:${value}`);

    setNewItem({
      name: item.name,
      price: item.price,
      category: item.category,
      imageUrl: item.imageUrl,
      imageUrlSub: item.imageUrlSub,
      ingredients: item.ingredients,
      is_visible: item.is_visible,
      recommendation_level: item.recommendation_level,
      estimated_time: item.estimated_time,
      recipe: item.recipe,
      isSoldOut: item.isSoldOut,
      nutrients: formattedNutrients,
    });
    setPreviewImage(item.imageUrl);
    setPreviewImageSub(item.imageUrlSub);
    setIngredientInputs([...item.ingredients.map((ing) => ing.name), ""]);
    setIngredientLocations(
      item.ingredients.reduce(
        (acc, ing) => ({
          ...acc,
          [ing.name]: ing.location,
        }),
        {}
      )
    );
    const nutrientObj = item.nutrients.reduce((acc, cur) => {
      const [key, val] = cur.split(":");
      const num = parseFloat(val);
      if (!isNaN(num)) acc[key] = num;
      return acc;
    }, {} as Record<string, number>);
    setNutrientValues(nutrientObj);
    onOpen();
    // „É¢„Éº„ÉÄ„É´„ÇíÈñã„ÅÑ„ÅüÂæå„Å´„ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢„ÅÆÈ´ò„Åï„ÇíË™øÊï¥
    setTimeout(() => {
      if (textareaRef.current) {
        adjustTextareaHeight(textareaRef.current);
      }
    }, 0);
  };

  const handleDelete = async (id: number) => {
    // ÂâäÈô§„Åô„Çã„Ç¢„Ç§„ÉÜ„É†„ÅÆÁîªÂÉèURL„ÇíÂèñÂæó
    const itemToDelete = menuItems.find((item) => item.id === id);
    if (!itemToDelete) return;

    try {
      // ÁîªÂÉè1„ÅÆ„Éï„Ç°„Ç§„É´Âêç„ÇíÂèñÂæó
      const imagePath = itemToDelete.imageUrl?.split("/").pop();
      // ÁîªÂÉè2„ÅÆ„Éï„Ç°„Ç§„É´Âêç„ÇíÂèñÂæóÔºàÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅÆ„ÅøÔºâ
      const imageSubPath = itemToDelete.imageUrlSub?.split("/").pop();

      // Supabase Storage„Åã„ÇâÁîªÂÉè„ÇíÂâäÈô§
      const pathsToDelete: string[] = [];
      if (imagePath) {
        const path = imagePath.split("?")[0]; // „ÇØ„Ç®„É™„Éë„É©„É°„Éº„Çø„ÇíÈô§Âéª
        pathsToDelete.push(path);
      }
      if (imageSubPath) {
        const path = imageSubPath.split("?")[0]; // „ÇØ„Ç®„É™„Éë„É©„É°„Éº„Çø„ÇíÈô§Âéª
        pathsToDelete.push(path);
      }

      if (pathsToDelete.length > 0) {
        const { error: deleteImageError } = await supabase.storage
          .from("menu-image")
          .remove(pathsToDelete);

        if (deleteImageError) {
          console.error("Error deleting image:", deleteImageError);
          toast({
            title: "„Ç®„É©„Éº",
            description: "ÁîªÂÉè„ÅÆÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
            status: "error",
            duration: 3000,
            isClosable: true,
          });
          return;
        }
      }

      // „Éá„Éº„Çø„Éô„Éº„Çπ„Åã„Çâ„Ç¢„Ç§„ÉÜ„É†„ÇíÂâäÈô§
      const { error: deleteItemError } = await supabase
        .from("order_menu_items")
        .delete()
        .eq("id", id);

      if (deleteItemError) {
        toast({
          title: "„Ç®„É©„Éº",
          description: "„É°„Éã„É•„Éº„Ç¢„Ç§„ÉÜ„É†„ÅÆÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
          status: "error",
          duration: 3000,
          isClosable: true,
        });
        return;
      }

      toast({
        title: "ÊàêÂäü",
        description: "„É°„Éã„É•„Éº„Ç¢„Ç§„ÉÜ„É†„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü",
        status: "success",
        duration: 3000,
        isClosable: true,
      });

      fetchMenuItems();
    } catch (error) {
      console.error("Error in delete process:", error);
      toast({
        title: "„Ç®„É©„Éº",
        description: "ÂâäÈô§Âá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
    }
  };

  const handleVisibilityChange = async (id: number, isVisible: boolean) => {
    if (userData?.user_company !== "ÈñãÁô∫") {
      toast({
        title: "„Ç®„É©„Éº",
        description: "„Åì„ÅÆÊ©üËÉΩ„ÅØ„Çµ„Éñ„Çπ„ÇØÂ•ëÁ¥ÑËÄÖ„ÅÆ„Åø‰ΩøÁî®„Åß„Åç„Åæ„Åô",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    const { error } = await supabase
      .from("order_menu_items")
      .update({ is_visible: isVisible })
      .eq("id", id);

    if (error) {
      toast({
        title: "„Ç®„É©„Éº",
        description: "Ë°®Á§∫Ë®≠ÂÆö„ÅÆÊõ¥Êñ∞„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    setMenuItems((prevItems) =>
      prevItems.map((item) =>
        item.id === id ? { ...item, is_visible: isVisible } : item
      )
    );
  };

  const handleSoldOutChange = async (id: number, isSoldOut: boolean) => {
    if (userData?.user_company !== "ÈñãÁô∫") {
      toast({
        title: "„Ç®„É©„Éº",
        description: "„Åì„ÅÆÊ©üËÉΩ„ÅØ„Çµ„Éñ„Çπ„ÇØÂ•ëÁ¥ÑËÄÖ„ÅÆ„Åø‰ΩøÁî®„Åß„Åç„Åæ„Åô",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
      return;
    }
    const { error } = await supabase
      .from("order_menu_items")
      .update({ isSoldOut: isSoldOut })
      .eq("id", id);

    if (error) {
      toast({
        title: "„Ç®„É©„Éº",
        description: "Â£≤„ÇäÂàá„ÇåÁä∂ÊÖã„ÅÆÊõ¥Êñ∞„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    setMenuItems((prevItems) =>
      prevItems.map((item) =>
        item.id === id ? { ...item, isSoldOut: isSoldOut } : item
      )
    );
  };

  const handleDeleteOrderItem = async (orderId: number, itemId: number) => {
    if (userData?.user_company !== "ÈñãÁô∫") {
      toast({
        title: "„Ç®„É©„Éº",
        description: "„Åì„ÅÆÊ©üËÉΩ„ÅØ„Çµ„Éñ„Çπ„ÇØÂ•ëÁ¥ÑËÄÖ„ÅÆ„Åø‰ΩøÁî®„Åß„Åç„Åæ„Åô",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    try {
      // Ê≥®Êñá„Ç¢„Ç§„ÉÜ„É†„ÇíÂâäÈô§
      const { error: itemError } = await supabase
        .from("order_items")
        .delete()
        .eq("id", itemId);

      if (itemError) throw itemError;

      // Ê≥®Êñá„ÅÆÂêàË®àÈáëÈ°ç„ÇíÂÜçË®àÁÆó
      const { data: remainingItems, error: remainingError } = await supabase
        .from("order_items")
        .select("price, quantity")
        .eq("order_id", orderId);

      if (remainingError) throw remainingError;

      const newTotal =
        remainingItems?.reduce(
          (sum, item) => sum + item.price * item.quantity,
          0
        ) || 0;

      // Ê≥®Êñá„ÅÆÂêàË®àÈáëÈ°ç„ÇíÊõ¥Êñ∞
      const { error: updateError } = await supabase
        .from("orders")
        .update({ total: newTotal })
        .eq("id", orderId);

      if (updateError) throw updateError;

      // Ê≥®Êñá„Å´„Ç¢„Ç§„ÉÜ„É†„ÅåÊÆã„Å£„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØÊ≥®ÊñáËá™‰Ωì„ÇíÂâäÈô§
      if (remainingItems?.length === 0) {
        const { error: deleteOrderError } = await supabase
          .from("orders")
          .delete()
          .eq("id", orderId);

        if (deleteOrderError) throw deleteOrderError;
      }

      toast({
        title: "ÊàêÂäü",
        description: "Ê≥®Êñá„Ç¢„Ç§„ÉÜ„É†„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü",
        status: "success",
        duration: 3000,
        isClosable: true,
      });

      fetchOrders();
    } catch (error) {
      console.error("Error deleting order item:", error);
      toast({
        title: "„Ç®„É©„Éº",
        description: "Ê≥®Êñá„Ç¢„Ç§„ÉÜ„É†„ÅÆÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
    }
  };

  const handleDeleteConfirm = async () => {
    if (!itemToDelete) return;
    await handleDelete(itemToDelete.id);
    onDeleteConfirmModalClose();
  };

  const handleCompleteConfirm = async (isSoldOut: boolean = false) => {
    if (!itemToComplete) return;

    try {
      // Ê≥®Êñá„Ç¢„Ç§„ÉÜ„É†„ÇíÂÆå‰∫Ü„Å´„Åô„Çã
      await handleOrderStatusChange(itemToComplete.id, "completed");

      // Â£≤„ÇäÂàá„Çå„Å´„Åô„ÇãÂ†¥Âêà
      if (isSoldOut) {
        const { error } = await supabase
          .from("order_menu_items")
          .update({ isSoldOut: true })
          .eq("id", itemToComplete.menuItemId);

        if (error) throw error;
      }

      onCompleteConfirmModalClose();
    } catch (error) {
      console.error("Error completing order:", error);
      toast({
        title: "„Ç®„É©„Éº",
        description: "Âá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
    }
  };

  // LocalStorage„Åã„Çâ„ÉÅ„Çß„ÉÉ„ÇØÁä∂ÊÖã„ÇíË™≠„ÅøËæº„ÇÄ
  useEffect(() => {
    const savedItems = localStorage.getItem("shoppingList");
    if (savedItems) {
      setCheckedItems(JSON.parse(savedItems));
    }
  }, []);

  // „ÉÅ„Çß„ÉÉ„ÇØÁä∂ÊÖã„ÇíLocalStorage„Å´‰øùÂ≠ò
  const saveToLocalStorage = (items: { [key: string]: boolean }) => {
    localStorage.setItem("shoppingList", JSON.stringify(items));
  };

  // „ÉÅ„Çß„ÉÉ„ÇØÁä∂ÊÖã„ÇíÂàá„ÇäÊõø„Åà„Çã
  const toggleItem = (ingredient: string) => {
    const newCheckedItems = {
      ...checkedItems,
      [ingredient]: !checkedItems[ingredient],
    };
    setCheckedItems(newCheckedItems);
    saveToLocalStorage(newCheckedItems);
  };

  // „ÉÅ„Çß„ÉÉ„ÇØÁä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
  const resetCheckedItems = () => {
    setCheckedItems({});
    localStorage.removeItem("shoppingList");
  };

  // ÈÅ∏Êäû„Åó„ÅüÊùêÊñô„Åß‰Ωú„Çå„Çã„É°„Éã„É•„Éº„Ç¢„Ç§„ÉÜ„É†„ÇíË°®Á§∫/ÈùûË°®Á§∫„Å´„Åô„Çã
  const applySelectedIngredients = async () => {
    onApplyConfirmModalClose();
    // „ÉÅ„Çß„ÉÉ„ÇØ„Åï„Çå„Å¶„ÅÑ„ÇãÊùêÊñô„ÇíÂèñÂæó
    const selectedIngredients = Object.entries(checkedItems)
      .filter(([_, isChecked]) => isChecked)
      .map(([ingredient]) => ingredient);

    // ÂêÑ„É°„Éã„É•„Éº„Ç¢„Ç§„ÉÜ„É†„Å´ÂØæ„Åó„Å¶
    for (const item of menuItems) {
      // ÂøÖË¶Å„Å™ÊùêÊñô„ÇíÂèñÂæó
      const requiredIngredients = item.ingredients.map((ing) => ing.name);

      // ÈÅ∏Êäû„Åó„ÅüÊùêÊñô„Åß‰Ωú„Çå„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
      const canMake = requiredIngredients.every((ing) =>
        selectedIngredients.includes(ing)
      );

      // Ë°®Á§∫Áä∂ÊÖã„ÇíÊõ¥Êñ∞
      const { error } = await supabase
        .from("order_menu_items")
        .update({ is_visible: canMake })
        .eq("id", item.id);

      if (error) {
        console.error("„É°„Éã„É•„Éº„Ç¢„Ç§„ÉÜ„É†„ÅÆÊõ¥Êñ∞„Å´Â§±Êïó:", error);
        continue;
      }

      // Â£≤„ÇäÂàá„ÇåÁä∂ÊÖã„ÇíËß£Èô§
      const { error: soldOutError } = await supabase
        .from("order_menu_items")
        .update({ isSoldOut: false })
        .eq("id", item.id);

      if (soldOutError) {
        console.error("Â£≤„ÇäÂàá„ÇåÁä∂ÊÖã„ÅÆÊõ¥Êñ∞„Å´Â§±Êïó:", soldOutError);
      }
    }

    // „É°„Éã„É•„Éº„Ç¢„Ç§„ÉÜ„É†„ÇíÂÜçÂèñÂæó
    await fetchMenuItems();

    toast({
      title: "ÂèçÊò†ÂÆå‰∫Ü",
      description: "ÈÅ∏Êäû„Åó„ÅüÊùêÊñô„Åß‰Ωú„Çå„Çã„É°„Éã„É•„Éº„ÇíË°®Á§∫„Åó„Åæ„Åó„Åü",
      status: "success",
      duration: 3000,
      isClosable: true,
    });
  };

  const handleAddItemClick = () => {
    resetNewItemForm(); // „É™„Çª„ÉÉ„ÉàÂÆüË°å
    onOpen(); // „É¢„Éº„ÉÄ„É´„Å™„Å©„ÇíÈñã„Åè
  };

  return (
    <Content>
      <Box p={{ base: "1", sm: "4" }}>
        <audio ref={audioRef} src="/sound/missed.mp3" preload="auto" />
        <Heading mb={6} textAlign="center">
          ÁÆ°ÁêÜËÄÖ„Éö„Éº„Ç∏
        </Heading>

        <Box>
          <HStack spacing={4} mb={4}>
            <Button colorScheme="blue" onClick={handleAddItemClick}>
              „Ç¢„Ç§„ÉÜ„É†„ÇíËøΩÂä†
            </Button>
            <Button colorScheme="green" onClick={onIngredientsModalOpen}>
              ‰ΩøÁî®ÊùêÊñô‰∏ÄË¶ß
            </Button>
          </HStack>

          <Heading size="md" mb={4}>
            Ê≥®Êñá‰∏ÄË¶ß
          </Heading>
          <VStack spacing={1} align="stretch" mb={8}>
            {orders.flatMap((order) => {
              const orderUserData = getUserById(order.user_id);
              return order.order_items.map((item) => (
                <Box
                  key={`${order.id}-${item.id}`}
                  p={1}
                  bg={colorMode === "light" ? "white" : "gray.700"}
                  borderRadius="md"
                >
                  <VStack align="stretch" spacing={1}>
                    <HStack spacing={2} justify="space-between">
                      <Image
                        src={item.menu_item.image_url}
                        alt={item.menu_item.name}
                        boxSize="50px"
                        minW="50px"
                        objectFit="cover"
                        borderRadius="md"
                        fallbackSrc="https://placehold.jp/150x150.png"
                      />
                      <Box textAlign="left" width="100%">
                        <Text fontWeight="bold">{item.menu_item.name}</Text>
                        <Text>{item.quantity}ÂÄã</Text>
                      </Box>
                      <VStack align="flex-end" gap="1">
                        <Button
                          size="sm"
                          colorScheme={
                            item.status === "pending" ? "green" : "gray"
                          }
                          onClick={() => {
                            if (userData?.user_company !== "ÈñãÁô∫") {
                              toast({
                                title: "„Ç®„É©„Éº",
                                description:
                                  "„Åì„ÅÆÊ©üËÉΩ„ÅØ„Çµ„Éñ„Çπ„ÇØÂ•ëÁ¥ÑËÄÖ„ÅÆ„Åø‰ΩøÁî®„Åß„Åç„Åæ„Åô",
                                status: "error",
                                duration: 3000,
                                isClosable: true,
                              });
                              return;
                            }
                            setItemToComplete({
                              id: item.id,
                              menuItemId: item.menu_item_id,
                            });
                            onCompleteConfirmModalOpen();
                          }}
                          isDisabled={item.status === "completed"}
                        >
                          ÂÆå‰∫Ü
                        </Button>
                        <Button
                          size="sm"
                          colorScheme="red"
                          onClick={() =>
                            handleDeleteOrderItem(order.id, item.id)
                          }
                        >
                          ÂâäÈô§
                        </Button>
                      </VStack>
                    </HStack>
                    <HStack>
                      {/* <Text fontWeight="bold">Ê≥®ÊñáID: {order.id}</Text>
                        <Text fontWeight="bold">„Ç¢„Ç§„ÉÜ„É†ID: {item.id}</Text> */}
                      <Text>
                        {new Date(order.created_at).toLocaleString("ja-JP", {
                          // month: "numeric",
                          // day: "numeric",
                          hour: "2-digit",
                          minute: "2-digit",
                          // second: "2-digit",
                        })}
                      </Text>
                      <Avatar
                        src={orderUserData?.picture_url || undefined}
                        size="xs"
                      />
                      <Button
                        size="xs"
                        colorScheme="blue"
                        variant="outline"
                        onClick={() => {
                          const menuItem = menuItems.find(
                            (m) => m.id === item.menu_item_id
                          );
                          if (menuItem) {
                            setSelectedRecipe(menuItem.recipe);
                            onRecipeModalOpen();
                          }
                        }}
                        display={
                          !menuItems.find((m) => m.id === item.menu_item_id)
                            ?.recipe
                            ? "none"
                            : "inline-block"
                        }
                      >
                        „É¨„Ç∑„Éî
                      </Button>
                    </HStack>
                  </VStack>
                </Box>
              ));
            })}
          </VStack>

          <Heading size="md" mb={4}>
            menu
          </Heading>

          <MyBarChart data2={filteredItems} />

          <Tabs variant="soft-rounded">
            <Flex
              alignItems="center"
              justifyContent="space-between"
              pb={1}
              ml={0}
            >
              <TabList
                overflowX="auto"
                display="flex"
                // alignItems="center"
                position="relative"
                sx={{
                  WebkitTapHighlightColor: "transparent",
                  // „Çπ„ÇØ„É≠„Éº„É´„Éê„ÉºÈùûË°®Á§∫
                  "::-webkit-scrollbar": {
                    display: "none",
                  },
                  // FirefoxÁî®
                  scrollbarWidth: "none",
                  // Edge/IEÁî®
                  msOverflowStyle: "none",
                }}
              >
                {categories.map((category) => {
                  // „Ç´„ÉÜ„Ç¥„É™„Åî„Å®„ÅÆ„Ç¢„Ç§„ÉÜ„É†Êï∞„ÇíË®àÁÆó
                  const count =
                    category === "„Åô„Åπ„Å¶"
                      ? menuItems.length
                      : menuItems.filter((item) => item.category === category)
                          .length;
                  return (
                    <Tab
                      p="1"
                      key={category}
                      onClick={() => handleCategoryChange(category)}
                      userSelect="none"
                      display="flex"
                      flexDirection="column"
                      justifyContent="flex-end"
                      alignItems="center"
                      _selected={{
                        bg: "transparent",
                      }}
                      _focus={{
                        boxShadow: "none",
                        bg: "transparent",
                      }}
                      sx={{
                        WebkitTapHighlightColor: "transparent",
                      }}
                    >
                      <Box
                        position="relative"
                        zIndex={1}
                        textAlign="center"
                        lineHeight={1.1}
                        color={
                          colorMode === "light"
                            ? "custom.theme.light.900"
                            : "custom.theme.light.400"
                        }
                      >
                        <Box
                          position="absolute"
                          width="100%"
                          bottom="0"
                          bg={searchCategoryBg(category)[0]}
                          mt={0}
                          height={
                            selectedCategory === category ? "103%" : "3px"
                          }
                          transition="all 0.3s ease-in-out"
                        />
                        <Box
                          zIndex={2}
                          position="relative"
                          color={
                            selectedCategory === category
                              ? searchCategoryColor(category)[0]
                              : colorMode === "light"
                              ? "custom.theme.light.850"
                              : "custom.theme.light.400"
                          }
                          transition="all 0.3s ease-in-out"
                          sx={{
                            display: { base: "flex", md: "inline-flex" },
                            flexDirection: "row",
                            alignItems: "center",
                            whiteSpace: "nowrap",
                            minWidth: "48px",
                            maxWidth: "100px",
                            overflow: "hidden",
                            textOverflow: "ellipsis",
                          }}
                        >
                          <Box as="span" display="inline">
                            {category}
                          </Box>
                          <Box
                            as="span"
                            color={
                              selectedCategory === category
                                ? searchCategoryColor(category)[0]
                                : colorMode === "light"
                                ? "custom.theme.light.850"
                                : "custom.theme.light.400"
                            }
                            sx={{
                              writingMode: "horizontal-tb",
                              display: "inline",
                              fontSize: "0.7em",
                            }}
                          >
                            ({count})
                          </Box>
                        </Box>
                      </Box>
                    </Tab>
                  );
                })}
              </TabList>
            </Flex>
          </Tabs>

          <HStack mb={2} _selected={{ bg: "transparent" }} bg="transparent">
            <Checkbox
              borderColor="custom.theme.light.800"
              isChecked={showVisibleOnly}
              onChange={(e) => setShowVisibleOnly(e.target.checked)}
            >
              Ë°®Á§∫„Åå„Ç™„É≥„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÅÆ„ÅøË°®Á§∫
            </Checkbox>
          </HStack>

          <VStack spacing={2} align="stretch">
            {(showVisibleOnly
              ? filteredItems.filter((item) => item.is_visible)
              : filteredItems
            )
              .sort((a, b) => {
                const orderA = categories.indexOf(a.category);
                const orderB = categories.indexOf(b.category);
                return orderA - orderB;
              })
              .map((item) => (
                <VStack
                  key={item.id}
                  position="relative"
                  align="stretch"
                  spacing={0.5}
                  bg={colorMode === "light" ? "white" : "gray.700"}
                  p={2}
                  borderRadius="md"
                  overflow="hidden"
                  opacity={item.is_visible ? "1" : "0.6"}
                >
                  <Box
                    position="absolute"
                    h="100%"
                    w="4px"
                    top="0"
                    left="0"
                    bg={searchCategoryBg(item.category)[0]}
                  />
                  <HStack justify="space-between">
                    <Text fontWeight="600">{item.name}</Text>
                    <Text>„Åä„Åô„Åô„ÇÅÂ∫¶: {item.recommendation_level}</Text>
                  </HStack>
                  <HStack
                    key={item.id}
                    borderRadius="md"
                    justify="space-between"
                  >
                    <HStack spacing={4} flex={1}>
                      <Image
                        src={
                          preloadedImages[item.imageUrl]?.src || item.imageUrl
                        }
                        alt={item.name}
                        boxSize="100px"
                        objectFit="cover"
                        mb={2}
                        fallbackSrc="https://placehold.jp/150x150.png"
                        filter={item.is_visible ? "none" : "sepia(1)"}
                      />
                      <Box>
                        {/* <Text>‰æ°Ê†º: {item.price}ÂÜÜ</Text> */}
                        <Text>„Ç´„ÉÜ„Ç¥„É™: {item.category}</Text>
                        <Box>
                          ÊùêÊñô:
                          {item.ingredients
                            .slice() // ÂÖÉ„ÅÆÈ†ÜÂ∫è„ÇíÂ£ä„Åï„Å™„ÅÑ„Çà„ÅÜ„Ç≥„Éî„Éº
                            .sort((a, b) => {
                              const orderA = locations.indexOf(a.location);
                              const orderB = locations.indexOf(b.location);
                              return orderA - orderB;
                            })
                            .map((ing, index) => (
                              <Box
                                as="span"
                                key={index}
                                position="relative"
                                fontWeight="bold"
                                mr="6px"
                                borderBottom="2px solid"
                                borderColor={locationTextColors[ing.location]}
                              >
                                {ing.name}
                              </Box>
                            ))}
                        </Box>
                        <Text>
                          Êõ¥Êñ∞Êó•:
                          {new Date(item.created_at).toLocaleDateString(
                            "ja-JP",
                            {
                              year: "numeric",
                              month: "long",
                              day: "numeric",
                            }
                          )}
                        </Text>
                        {item.user_id && (
                          <Avatar
                            src={getUserById(item.user_id)?.picture_url}
                            size="xs"
                            ml={1}
                          />
                        )}
                        <Button
                          size="xs"
                          ml={1}
                          colorScheme="blue"
                          variant="outline"
                          onClick={() => {
                            const menuItem = menuItems.find(
                              (m) => m.id === item.id
                            );
                            if (menuItem) {
                              setSelectedRecipe(menuItem.recipe);
                              onRecipeModalOpen();
                            }
                          }}
                          display={
                            !menuItems.find((m) => m.id === item.id)?.recipe
                              ? "none"
                              : "inline-block"
                          }
                        >
                          „É¨„Ç∑„Éî
                        </Button>
                      </Box>
                    </HStack>
                    <VStack align="flex-end">
                      <Checkbox
                        isChecked={item.is_visible}
                        onChange={(e) =>
                          handleVisibilityChange(item.id, e.target.checked)
                        }
                      >
                        Ë°®Á§∫
                      </Checkbox>
                      <Checkbox
                        isChecked={item.isSoldOut}
                        onChange={(e) =>
                          handleSoldOutChange(item.id, e.target.checked)
                        }
                        colorScheme="red"
                      >
                        Â£≤Âàá
                      </Checkbox>
                      <Button
                        size="sm"
                        colorScheme="blue"
                        onClick={() => handleEdit(item)}
                      >
                        Á∑®ÈõÜ
                      </Button>
                      <Button
                        size="sm"
                        colorScheme="red"
                        onClick={() => {
                          if (userData?.user_company !== "ÈñãÁô∫") {
                            toast({
                              title: "„Ç®„É©„Éº",
                              description:
                                "„Åì„ÅÆÊ©üËÉΩ„ÅØ„Çµ„Éñ„Çπ„ÇØÂ•ëÁ¥ÑËÄÖ„ÅÆ„Åø‰ΩøÁî®„Åß„Åç„Åæ„Åô",
                              status: "error",
                              duration: 3000,
                              isClosable: true,
                            });
                            return;
                          }
                          setItemToDelete({ id: item.id });
                          onDeleteConfirmModalOpen();
                        }}
                      >
                        ÂâäÈô§
                      </Button>
                    </VStack>
                  </HStack>
                </VStack>
              ))}
          </VStack>

          <Modal isOpen={isOpen} onClose={onClose} size="xl">
            <ModalOverlay />
            <ModalContent>
              <ModalHeader>
                „É°„Éã„É•„Éº„Ç¢„Ç§„ÉÜ„É†„ÅÆ{editingItem ? "Á∑®ÈõÜ" : "ËøΩÂä†"}
              </ModalHeader>
              <ModalCloseButton />
              <form onSubmit={handleSubmit}>
                <ModalBody>
                  <VStack spacing={4} align="stretch">
                    <FormControl>
                      <FormLabel>ÂïÜÂìÅÂêç</FormLabel>
                      <Input
                        value={newItem.name}
                        onChange={(e) =>
                          setNewItem({ ...newItem, name: e.target.value })
                        }
                        required
                      />
                    </FormControl>

                    <FormControl>
                      <FormLabel>‰æ°Ê†º</FormLabel>
                      <Input
                        type="text"
                        inputMode="numeric"
                        value={newItem.price === undefined ? "" : newItem.price}
                        onChange={handlePriceChange}
                        placeholder="‰æã: 1000"
                        required
                      />
                    </FormControl>

                    <FormControl>
                      <FormLabel>„Ç´„ÉÜ„Ç¥„É™</FormLabel>
                      <Select
                        value={newItem.category}
                        onChange={(e) =>
                          setNewItem({ ...newItem, category: e.target.value })
                        }
                        required
                      >
                        <option value="">ÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</option>
                        {categories.map((category) => (
                          <option key={category} value={category}>
                            {category}
                          </option>
                        ))}
                      </Select>
                    </FormControl>

                    <FormControl>
                      <FormLabel>ÁîªÂÉè1</FormLabel>
                      <Input
                        type="file"
                        accept="image/*"
                        onChange={(e) => handleImageUpload(e, false)}
                        ref={fileInputRef}
                        display="none"
                      />
                      <Button
                        onClick={() => fileInputRef.current?.click()}
                        colorScheme="blue"
                        variant="outline"
                        w="full"
                      >
                        ÁîªÂÉè1„ÇíÈÅ∏Êäû
                      </Button>
                      {previewImage && (
                        <Box mt={2}>
                          <Image
                            src={previewImage}
                            alt="„Éó„É¨„Éì„É•„Éº"
                            maxH="200px"
                            objectFit="contain"
                          />
                        </Box>
                      )}
                    </FormControl>

                    <FormControl>
                      <FormLabel>ÁîªÂÉè2</FormLabel>
                      <Input
                        type="file"
                        accept="image/*"
                        onChange={(e) => handleImageUpload(e, true)}
                        ref={fileInputSubRef}
                        display="none"
                      />
                      <Button
                        onClick={() => fileInputSubRef.current?.click()}
                        colorScheme="blue"
                        variant="outline"
                        w="full"
                      >
                        ÁîªÂÉè2„ÇíÈÅ∏Êäû
                      </Button>
                      {previewImageSub && (
                        <Box mt={2}>
                          <Image
                            src={previewImageSub}
                            alt="„Éó„É¨„Éì„É•„Éº2"
                            maxH="200px"
                            objectFit="contain"
                          />
                        </Box>
                      )}
                    </FormControl>

                    <FormControl>
                      <FormLabel>ÊùêÊñô</FormLabel>
                      <VStack spacing={2} align="stretch">
                        {ingredientInputs.map((ingredient, index) => (
                          <HStack key={index} spacing={2}>
                            <Input
                              value={ingredient}
                              onChange={(e) =>
                                handleIngredientChange(index, e.target.value)
                              }
                              placeholder="ÊùêÊñô„ÇíÂÖ•Âäõ"
                              mb={2}
                            />
                            {ingredient && (
                              <Button
                                size="sm"
                                onClick={() => {
                                  setSelectedIngredient(ingredient);
                                  onLocationModalOpen();
                                }}
                              >
                                {ingredientLocations[ingredient] ||
                                  "Â£≤„ÇäÂ†¥„ÇíÈÅ∏Êäû"}
                              </Button>
                            )}
                          </HStack>
                        ))}
                      </VStack>
                    </FormControl>
                    <FormControl>
                      <FormLabel>‰Ωú„ÇäÊñπ</FormLabel>
                      <Box>
                        <Button
                          colorScheme="blue"
                          onClick={handleCopyToClipboardRecipe}
                        >
                          „É¨„Ç∑„ÉîÂÆöÂûãÂàÜ
                        </Button>
                      </Box>
                      <Textarea
                        ref={textareaRef}
                        value={newItem.recipe}
                        onChange={handleRecipeChange}
                        placeholder="„É¨„Ç∑„Éî„ÇíÂÖ•Âäõ"
                        mb={2}
                        resize="none"
                        _focus={{
                          borderColor: "custom.theme.light.850",
                          borderWidth: "1px",
                          boxShadow: "none",
                        }}
                        sx={{
                          height: "auto",
                          maxHeight: "none",
                          overflow: "hidden",
                        }}
                      />
                    </FormControl>
                    <FormControl>
                      <Box>
                        Ê†ÑÈ§äÁ¥†
                        <Box>
                          <Button
                            colorScheme="blue"
                            onClick={handleCopyToClipboardNutrients}
                          >
                            Ê†ÑÈ§äÁ¥†ÂÆöÂûãÂàÜ
                          </Button>
                        </Box>
                        {Object.entries(NUTRIENTS_CONFIG_).map(
                          ([label, { unit }]) => (
                            <FormControl key={label}>
                              <FormLabel>{label}</FormLabel>
                              <InputGroup>
                                <NumberInput
                                  value={
                                    isNaN(nutrientValues[label])
                                      ? 0
                                      : nutrientValues[label]
                                  } // NaN„ÅÆÂ†¥Âêà„ÅØ0„ÇíË°®Á§∫
                                  onChange={(_, value) =>
                                    handleChange(label, value)
                                  }
                                  min={0}
                                  step={0.1}
                                  precision={1}
                                  clampValueOnBlur={false} // ÂÖ•Âäõ‰∏≠„ÅÆÂà∂Èôê„ÇíÁ∑©Âíå
                                  allowMouseWheel // „Éû„Ç¶„Çπ„Éõ„Ç§„Éº„É´„Åß„ÅÆÂÄ§Â§âÊõ¥„ÇíË®±ÂèØ
                                >
                                  <NumberInputField
                                    onChange={(e) => {
                                      const inputValue = e.target.value;
                                      // Êï∞ÂÄ§„Å®Â∞èÊï∞ÁÇπ„ÅÆ„Åø„ÇíË®±ÂèØ
                                      if (
                                        /^[0-9]*[.]?[0-9]*$/.test(inputValue) ||
                                        inputValue === ""
                                      ) {
                                        handleChange(
                                          label,
                                          parseFloat(inputValue) || 0
                                        );
                                      }
                                    }}
                                  />
                                  <NumberInputStepper>
                                    <NumberIncrementStepper />
                                    <NumberDecrementStepper />
                                  </NumberInputStepper>
                                </NumberInput>
                                <InputRightAddon children={unit} />
                              </InputGroup>
                            </FormControl>
                          )
                        )}
                      </Box>
                    </FormControl>
                    <FormControl>
                      <FormLabel>Êèê‰æõÁõÆÂÆâÊôÇÈñìÔºàÂàÜÔºâ</FormLabel>
                      <Input
                        type="number"
                        value={newItem.estimated_time}
                        onChange={(e) =>
                          setNewItem({
                            ...newItem,
                            estimated_time: Number(e.target.value),
                          })
                        }
                        required
                      />
                    </FormControl>

                    <FormControl>
                      <Checkbox
                        isChecked={newItem.is_visible}
                        onChange={(e) =>
                          setNewItem({
                            ...newItem,
                            is_visible: e.target.checked,
                          })
                        }
                      >
                        Ê≥®Êñá„Éö„Éº„Ç∏„ÅßË°®Á§∫
                      </Checkbox>
                    </FormControl>

                    <FormControl>
                      <FormLabel>„Åä„Åô„Åô„ÇÅÂ∫¶ (0-5)</FormLabel>
                      <Select
                        value={newItem.recommendation_level}
                        onChange={(e) =>
                          setNewItem({
                            ...newItem,
                            recommendation_level: Number(e.target.value),
                          })
                        }
                      >
                        {[0, 1, 2, 3, 4, 4.5, 5].map((level) => (
                          <option key={level} value={level}>
                            {level}
                          </option>
                        ))}
                      </Select>
                    </FormControl>
                  </VStack>
                </ModalBody>

                <ModalFooter>
                  <Button colorScheme="blue" mr={3} type="submit">
                    {editingItem ? "Êõ¥Êñ∞" : "ËøΩÂä†"}
                  </Button>
                  <Button variant="ghost" onClick={onClose}>
                    „Ç≠„É£„É≥„Çª„É´
                  </Button>
                </ModalFooter>
              </form>
            </ModalContent>
          </Modal>

          <Modal
            isOpen={isIngredientsModalOpen}
            onClose={onIngredientsModalClose}
            size="md"
          >
            <ModalOverlay />
            <ModalContent>
              <ModalHeader>‰ΩøÁî®ÊùêÊñô‰∏ÄË¶ß</ModalHeader>
              <ModalCloseButton />
              <ModalBody>
                <VStack align="stretch" spacing={4}>
                  {locations.map((location) => {
                    // location„Åî„Å®„Å´ÊùêÊñôÂêç„Å®‰Ωø„Çè„Çå„Å¶„ÅÑ„Çã„É°„Éã„É•„ÉºÂêç„É™„Çπ„Éà„Çí‰ΩúÊàê
                    const ingredientMap: { [ingredient: string]: Set<string> } =
                      {};

                    menuItems
                      .filter((item) => item.is_visible)
                      .forEach((item) => {
                        item.ingredients
                          .filter((ing) => ing.location === location)
                          .forEach((ing) => {
                            if (!ingredientMap[ing.name]) {
                              ingredientMap[ing.name] = new Set();
                            }
                            ingredientMap[ing.name].add(item.name);
                          });
                      });

                    const locationIngredients = Object.entries(ingredientMap)
                      .map(([name, menuSet]) => ({
                        name,
                        menuNames: Array.from(menuSet),
                      }))
                      .sort((a, b) => a.name.localeCompare(b.name));

                    if (locationIngredients.length === 0) return null;

                    return (
                      <Box key={location}>
                        <Flex justify="center" mb={4}>
                          <Box
                            position="relative"
                            fontWeight="bold"
                            color={locationTextColors[location]}
                            p={0}
                            borderRadius="md"
                          >
                            {location}
                            <Box
                              position="absolute"
                              height="3px"
                              width="100%"
                              bottom="0"
                              bg={locationTextColors[location]}
                            />
                          </Box>
                        </Flex>
                        <VStack align="stretch" spacing={2}>
                          {locationIngredients.map((ingredient) => (
                            <HStack
                              key={ingredient.name}
                              p={2}
                              userSelect="none"
                              border="1px solid"
                              borderColor="custom.theme.light.800"
                              bg={
                                checkedItems[ingredient.name]
                                  ? "gray.200"
                                  : "gray.600"
                              }
                              borderRadius="md"
                              cursor="pointer"
                              onClick={() => toggleItem(ingredient.name)}
                              textAlign="center"
                              alignItems="center" // ÂûÇÁõ¥‰∏≠Â§ÆÂØÑ„Åõ
                              justifyContent="center" // Ê∞¥Âπ≥‰∏≠Â§ÆÂØÑ„Åõ
                            >
                              <Checkbox
                                isChecked={
                                  checkedItems[ingredient.name] || false
                                }
                                onChange={() => {}}
                                pointerEvents="none"
                                display="none"
                              />
                              <Text
                                textDecoration={
                                  checkedItems[ingredient.name]
                                    ? "line-through"
                                    : "none"
                                }
                                color={
                                  checkedItems[ingredient.name]
                                    ? "gray.600"
                                    : colorMode === "light"
                                    ? "white"
                                    : "white"
                                }
                              >
                                {ingredient.name}
                                <span
                                  style={{
                                    fontSize: "0.8em",
                                    color: "#888",
                                  }}
                                >
                                  Ôºà{ingredient.menuNames.join("/")}Ôºâ
                                </span>
                              </Text>
                            </HStack>
                          ))}
                        </VStack>
                      </Box>
                    );
                  })}
                </VStack>
              </ModalBody>
              <ModalFooter>
                <Button
                  colorScheme="blue"
                  mr={3}
                  onClick={onIngredientsModalClose}
                >
                  Èñâ„Åò„Çã
                </Button>
                <Button
                  colorScheme="green"
                  mr={3}
                  onClick={onApplyConfirmModalOpen}
                >
                  ÂèçÊò†
                </Button>
                <Button colorScheme="red" onClick={resetCheckedItems}>
                  „É™„Çπ„Éà„Çí„ÇØ„É™„Ç¢
                </Button>
              </ModalFooter>
            </ModalContent>
          </Modal>

          <Modal
            isOpen={isRecipeModalOpen}
            onClose={onRecipeModalClose}
            size="md"
          >
            <ModalOverlay />
            <ModalContent>
              {/* <ModalHeader>‰Ωú„ÇäÊñπ</ModalHeader> */}
              <ModalCloseButton />
              <ModalBody>
                <Text whiteSpace="pre-wrap">{selectedRecipe}</Text>
              </ModalBody>
              <ModalFooter>
                <Button colorScheme="blue" onClick={onRecipeModalClose}>
                  Èñâ„Åò„Çã
                </Button>
              </ModalFooter>
            </ModalContent>
          </Modal>

          <Modal
            isOpen={isDeleteConfirmModalOpen}
            onClose={onDeleteConfirmModalClose}
            size="sm"
          >
            <ModalOverlay />
            <ModalContent>
              <ModalHeader>ÂâäÈô§„ÅÆÁ¢∫Ë™ç</ModalHeader>
              <ModalCloseButton />
              <ModalBody>
                <Text>„Åì„ÅÆ„É°„Éã„É•„Éº„Ç¢„Ç§„ÉÜ„É†„ÇíÂâäÈô§„Åó„Å¶„ÇÇ„Çà„Çç„Åó„ÅÑ„Åß„Åô„ÅãÔºü</Text>
              </ModalBody>
              <ModalFooter>
                <Button colorScheme="red" mr={3} onClick={handleDeleteConfirm}>
                  ÂâäÈô§
                </Button>
                <Button variant="ghost" onClick={onDeleteConfirmModalClose}>
                  „Ç≠„É£„É≥„Çª„É´
                </Button>
              </ModalFooter>
            </ModalContent>
          </Modal>

          <Modal
            isOpen={isCompleteConfirmModalOpen}
            onClose={onCompleteConfirmModalClose}
            size="sm"
          >
            <ModalOverlay />
            <ModalContent>
              <ModalHeader>ÂÆå‰∫Ü„ÅÆÁ¢∫Ë™ç</ModalHeader>
              <ModalCloseButton />
              <ModalBody>
                <Text>„Åì„ÅÆÊ≥®Êñá„ÇíÂÆå‰∫Ü„Åó„Åæ„Åô„ÅãÔºü</Text>
              </ModalBody>
              <ModalFooter>
                <Button
                  colorScheme="green"
                  mr={3}
                  onClick={() => handleCompleteConfirm(false)}
                >
                  ÂÆå‰∫Ü„Å´„Åô„Çã
                </Button>
                <Button
                  colorScheme="orange"
                  mr={3}
                  onClick={() => handleCompleteConfirm(true)}
                >
                  Â£≤„ÇäÂàá„Çå„Å´„Åó„Å¶ÂÆå‰∫Ü
                </Button>
                <Button variant="ghost" onClick={onCompleteConfirmModalClose}>
                  „Ç≠„É£„É≥„Çª„É´
                </Button>
              </ModalFooter>
            </ModalContent>
          </Modal>

          <Modal
            isOpen={isLocationModalOpen}
            onClose={onLocationModalClose}
            size="sm"
          >
            <ModalOverlay />
            <ModalContent>
              <ModalHeader>Â£≤„ÇäÂ†¥„ÇíÈÅ∏Êäû</ModalHeader>
              <ModalCloseButton />
              <ModalBody>
                <VStack spacing={2} align="stretch">
                  {locations.map((location) => (
                    <Button
                      key={location}
                      onClick={() => handleLocationSelect(location)}
                      variant="ghost"
                      justifyContent="flex-start"
                    >
                      {location}
                    </Button>
                  ))}
                </VStack>
              </ModalBody>
            </ModalContent>
          </Modal>

          <Modal
            isOpen={isApplyConfirmModalOpen}
            onClose={onApplyConfirmModalClose}
            size="sm"
          >
            <ModalOverlay />
            <ModalContent>
              <ModalHeader>Á¢∫Ë™ç</ModalHeader>
              <ModalCloseButton />
              <ModalBody>
                <Text>
                  ÈÅ∏Êäû„Åó„ÅüÊùêÊñô„Åß‰Ωú„Çå„Çã„É°„Éã„É•„Éº„ÇíË°®Á§∫„Åó„ÄÅ„Åù„Çå‰ª•Â§ñ„ÇíÈùûË°®Á§∫„Å´„Åó„Åæ„Åô„ÄÇ
                  „Åæ„Åü„ÄÅÂÖ®„Å¶„ÅÆ„É°„Éã„É•„Éº„ÅÆÂ£≤„ÇäÂàá„ÇåÁä∂ÊÖã„ÇíËß£Èô§„Åó„Åæ„Åô„ÄÇ
                  „Çà„Çç„Åó„ÅÑ„Åß„Åô„ÅãÔºü
                </Text>
              </ModalBody>
              <ModalFooter>
                <Button
                  colorScheme="blue"
                  mr={3}
                  onClick={applySelectedIngredients}
                >
                  ÂèçÊò†„Åô„Çã
                </Button>
                <Button variant="ghost" onClick={onApplyConfirmModalClose}>
                  „Ç≠„É£„É≥„Çª„É´
                </Button>
              </ModalFooter>
            </ModalContent>
          </Modal>
        </Box>
      </Box>
    </Content>
  );
}
